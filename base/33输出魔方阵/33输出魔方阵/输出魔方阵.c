/*连续摆数法*/

//#include <stdio.h>
//#define N  5
//
//int main()
//{
//	int arr[N][N] = { 0 };
//	int num = N*N;
//	int i=0, j=0;
//	int start = 1;
//	arr[1][7] = 1;
//	num = num - 1;
//	int k = 0;
//	i = 1; j = 8;
//	for (k = 2; k < N*N; k++)
//	{
//		i = i - 1;
//		j = j + 1;    // 从2开始直到n×n止各数依次按下列规则存放：按 45°向右上方向行走，也即行数减一，列数加一
//		if ((i<1) && (j>N))  //这里是判断是否到了第1行第n列时，如果是，将下一个数放到上一个数的下面
//		{
//			i = i + 2;
//			j = j - 1;
//		}
//		else   //如果不是，又有以下情况
//		{
//			if (i<1)i = N;   //如果行数到了第一列，那么回绕，即放在最后一行
//			if (j>N)j = 1;   //如果列数到了最后一列，那么同样回绕，即放在第一列
//		}
//		if (arr[i][j] == 0)  //如果按上面规则确定的位置上没有数，那么就放在该位置
//			arr[i][j] = k;
//		else    //如果按上面规则确定的位置上已有数，那么也是将下一个数放到上一个数的下面
//		{
//			i = i + 2;
//			j = j - 1;
//			arr[i][j] = k;
//		}
//	}
//	for (i = 0; i < N; i++)
//	{
//		for (j = 0; j < N; j++)
//			printf("%d ", arr[i][j]);
//		printf("\n");
//	}
//}


#include <stdio.h>
int main()
{
	int a[15][15];
	int i, j, k, p, n;
	p = 1;
	while (p = 1)   //我觉得这里应该是p==1，否则p=1是赋值语句，导致while判断没有效果，会一直循环
	{
		printf("请输入n,(n=1―15)：");
		scanf("%d", &n);
		if ((n != 0) && (n <= 15) && (n % 2 != 0))  //这里就是判断是否为1至15的奇数了，因为你这个魔方算法只适合于奇数
			p = 0;
		for (i = 1; i <= n; i++)
		for (j = 1; j <= n; j++)
			a[i][j] = 0;  //这里是数组初始化，你也懂的
		j = n / 2 + 1;
		a[1][j] = 1;   //这里是将1放在矩阵的第一行的中间位置
		for (k = 2; k <= n*n; k++)
		{
			i = i - 1;
			j = j + 1;    // 从2开始直到n×n止各数依次按下列规则存放：按 45°向右上方向行走，也即行数减一，列数加一
			if ((i<1) && (j>n))  //这里是判断是否到了第1行第n列时，如果是，将下一个数放到上一个数的下面
			{
				i = i + 2;
				j = j - 1;
			}
			else   //如果不是，又有以下情况
			{
				if (i<1)i = n;   //如果行数到了第一列，那么回绕，即放在最后一行
				if (j>n)j = 1;   //如果列数到了最后一列，那么同样回绕，即放在第一列
			}
			if (a[i][j] == 0)  //如果按上面规则确定的位置上没有数，那么就放在该位置
				a[i][j] = k;
			else    //如果按上面规则确定的位置上已有数，那么也是将下一个数放到上一个数的下面
			{
				i = i + 2;
				j = j - 1;
				a[i][j] = k;
			}
		}
		for (i = 1; i <= n; i++)
		{
			for (j = 1; j <= n; j++)
				printf("%5d", a[i][j]);   //将阵列输出，这个你懂的
			printf("\n");
		}
		printf("\n\n");
	}
	return 0;
}